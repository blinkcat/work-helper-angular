{"version":3,"file":"static/iframe.4f449d6882a81110f544.bundle.js","sources":["webpack:///./projects/components/light/light.component.ts"],"sourcesContent":["import {\n  Component,\n  AfterViewInit,\n  OnChanges,\n  ViewEncapsulation,\n  Renderer2,\n  ElementRef,\n  Input,\n  ViewChild,\n  TemplateRef,\n  ChangeDetectionStrategy\n} from '@angular/core';\nimport { trigger, style, animate, transition, AnimationEvent } from '@angular/animations';\nimport { Subject } from 'rxjs';\nimport { BcLightTarget, BcLightContainer } from './light.service';\n\n@Component({\n  selector: 'bc-light',\n  template: `\n    <ng-template #defaultTemplate>\n      <p class=\"bc-light-tip-content\">{{ contentText }}</p>\n      <div class=\"bc-light-tip-dismiss\">{{ dismissText }}</div>\n    </ng-template>\n\n    <canvas class=\"bc-light-canvas\" #canvas @inOut (@inOut.done)=\"animationDone($event)\" *ngIf=\"!clickToClose\"></canvas>\n    <div class=\"bc-light-tip\" @inOut #lightContent *ngIf=\"!clickToClose\">\n      <ng-template [ngTemplateOutlet]=\"customTemplate || defaultTemplate\"></ng-template>\n    </div>\n  `,\n  styles: [require('./light.component.scss')],\n  /* tslint:disable:use-host-property-decorator */\n  host: {\n    class: 'bc-light',\n    '(click)': 'close()'\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  animations: [\n    trigger('inOut', [\n      transition(':enter', [style({ opacity: 0 }), animate(300, style({ opacity: 1 }))]),\n      transition(':leave', [animate(300, style({ opacity: 0 }))])\n    ])\n  ]\n})\nexport class LightComponent implements OnChanges, AfterViewInit {\n  @Input() target!: BcLightTarget | null;\n  @Input() container!: BcLightContainer;\n  @Input() padding = 5;\n  @Input() indicatorShape: BcLightShape = 'roundedRect';\n  @Input() contentText = '这是一个新功能';\n  @Input() dismissText = '知道了';\n  @Input() customTemplate!: TemplateRef<any>;\n  @Input() noContextAutoAdjust = false;\n\n  @ViewChild('canvas') canvas!: ElementRef<HTMLCanvasElement>;\n  @ViewChild('lightContent') lightContent!: ElementRef<HTMLElement>;\n\n  clickToClose = false;\n\n  get closeDone() {\n    return this._closeDone.asObservable();\n  }\n\n  private _closeDone = new Subject();\n\n  constructor(private render: Renderer2) {}\n\n  ngOnChanges() {\n    this.initCanvas();\n    this.draw(true);\n  }\n\n  ngAfterViewInit() {\n    this.initCanvas();\n    this.draw();\n  }\n\n  close() {\n    this.clickToClose = true;\n  }\n\n  animationDone(event: AnimationEvent) {\n    if (event.toState === 'void') {\n      this._closeDone.next();\n    }\n  }\n\n  private initCanvas() {\n    const container = this.container;\n    const canvas = this.canvas.nativeElement;\n\n    this.render.setProperty(canvas, 'width', container.width);\n    this.render.setProperty(canvas, 'height', container.height);\n  }\n\n  private draw(redrawing = false) {\n    const canvas = this.canvas.nativeElement;\n    const ctx = canvas.getContext('2d');\n\n    const container = this.container;\n\n    if (ctx) {\n      if (redrawing) {\n        ctx.clearRect(0, 0, container.width, container.height);\n      }\n      this.setCtxBg(ctx);\n      this.drawBg(ctx, container.width, container.height);\n      this.drawLight(ctx, this.indicatorShape);\n      this.fill(ctx);\n    }\n  }\n\n  private drawBg(ctx: CanvasRenderingContext2D, width: number, height: number) {\n    // 逆时针\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, height);\n    ctx.lineTo(width, height);\n    ctx.lineTo(width, 0);\n    ctx.closePath();\n  }\n\n  private drawLight(ctx: CanvasRenderingContext2D, shape: BcLightShape) {\n    if (!this.target) {\n      return;\n    }\n\n    const target = this.target;\n    const padding = this.padding;\n\n    const top = target.top + document.documentElement!.scrollTop || document.body.scrollTop;\n    const left = target.left + document.documentElement!.scrollLeft || document.body.scrollLeft;\n\n    switch (shape) {\n      case 'rect':\n        this.rect(ctx, left - padding, top - padding, target.width + padding * 2, target.height + padding * 2);\n        break;\n      case 'round':\n        this.round(\n          ctx,\n          left + target.width / 2,\n          top + target.height / 2,\n          Math.max(target.width, target.height) / 2 + padding\n        );\n        break;\n      case 'roundedRect':\n        this.roundedRect(\n          ctx,\n          left - padding,\n          top - padding,\n          target.width + padding * 2,\n          target.height + padding * 2,\n          6.5\n        );\n        break;\n      default:\n        this.rect(ctx, left - padding, top - padding, target.width + padding * 2, target.height + padding * 2);\n    }\n\n    // 适配文字位置\n    if (!this.noContextAutoAdjust) {\n      const lightContent = this.lightContent.nativeElement;\n\n      const halfScreenWidth = window.innerWidth / 2;\n\n      if (target.left + target.width / 2 > halfScreenWidth) {\n        this.render.setStyle(lightContent, 'left', `${left - lightContent.offsetWidth}px`);\n      } else {\n        this.render.setStyle(lightContent, 'left', `${left}px`);\n      }\n\n      const halfScreenHeight = window.innerHeight / 2;\n\n      if (target.top + target.height / 2 > halfScreenHeight) {\n        this.render.setStyle(lightContent, 'top', `${top - lightContent.offsetHeight}px`);\n      } else {\n        this.render.setStyle(lightContent, 'top', `${top + target.height}px`);\n      }\n    }\n  }\n\n  private setCtxBg(ctx: CanvasRenderingContext2D, bgColor = 'rgba(0,0,0,0.5)') {\n    ctx.fillStyle = bgColor;\n  }\n\n  private fill(ctx: CanvasRenderingContext2D) {\n    ctx.fill();\n  }\n\n  // #region 顺时针绘制各种图形\n  // 矩形\n  private rect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number) {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n    ctx.closePath();\n  }\n\n  // 圆形\n  private round(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number) {\n    ctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n  }\n\n  // 圆角矩形\n  private roundedRect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number\n  ) {\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n  }\n  // #endregion\n}\n\nexport type BcLightShape = 'rect' | 'round' | 'roundedRect';\n"],"mappings":"AA4CA","sourceRoot":""}